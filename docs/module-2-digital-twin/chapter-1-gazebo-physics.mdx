---
sidebar_position: 1
title: "Gazebo Physics Simulation"
description: "Understanding physics engines, rigid body dynamics, and collision detection"
---

# Gazebo Physics Simulation

## Introduction: Why Physics Simulation Matters

A digital twin is only as useful as the accuracy of its physics. Before deploying a humanoid robot in the real world, engineers must test control algorithms, verify stability margins, and validate sensor configurations. Running these experiments on physical hardware is expensive, time-consuming, and potentially dangerous—a fall can damage costly actuators or injure nearby people.

Physics simulation provides a safe, repeatable environment for development. You can simulate thousands of falls in minutes, test edge cases that would be impractical to create physically, and iterate on designs before manufacturing. For humanoid robots, accurate physics simulation is essential because balance depends critically on dynamic interactions between the robot and its environment (Koenig & Howard, 2004).

## Physics Engines in Gazebo

Gazebo Sim supports multiple physics engines, each with different strengths:

:::info What is a Physics Engine?
A **physics engine** calculates forces, collisions, and motion for every object in the simulated world, updating positions and velocities at each time step. It transforms your robot model into a dynamic system that responds to gravity, contacts, and applied forces.
:::

| Engine | Strengths | Best For |
|--------|-----------|----------|
| **ODE** (Open Dynamics Engine) | General-purpose, well-tested, default | Most applications, proven stability |
| **Bullet** | GPU acceleration, soft body support | Large scenes, deformable objects |
| **DART** | Accurate constraint solving, research-focused | Manipulation, contact-rich tasks |

For humanoid robots, the choice often comes down to ODE for general development and DART for tasks requiring precise contact modeling like manipulation or walking on uneven terrain. Bullet becomes advantageous when simulating many objects simultaneously or when you need soft body dynamics for clothing or padding.

## Rigid Body Dynamics

Physics engines solve the Newton-Euler equations that govern rigid body motion. For each body in the simulation, the engine computes:

**Linear dynamics**: Force equals mass times acceleration (F = ma)
**Angular dynamics**: Torque equals moment of inertia times angular acceleration (τ = Iα)

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Forces    │────▶│  Dynamics   │────▶│  Position   │
│   Applied   │     │  Solver     │     │  Update     │
└─────────────┘     └─────────────┘     └─────────────┘
       │                   │                   │
       │                   ▼                   │
       │           ┌─────────────┐             │
       └──────────▶│  Collision  │◀────────────┘
                   │  Detection  │
                   └─────────────┘
```

The **inertia tensor** (a 3×3 matrix describing mass distribution) is critical for humanoid simulation. A robot with incorrect inertia values will rotate unrealistically—too fast, too slow, or about the wrong axis. This is why accurate URDF `<inertial>` elements matter so much.

Integration methods determine how the engine advances positions and velocities:
- **Explicit Euler**: Simple but can be unstable at large time steps
- **Semi-implicit Euler**: More stable, used by most real-time simulators
- **Implicit methods**: Most stable but computationally expensive

## Collision Detection and Response

Collision detection runs in two phases to balance accuracy with performance:

**Broad phase** quickly identifies pairs of objects that *might* collide:
- Axis-Aligned Bounding Boxes (AABB) enclose each object
- Spatial hashing divides the world into cells
- Only overlapping pairs proceed to narrow phase

**Narrow phase** precisely determines contact points:
- GJK (Gilbert-Johnson-Keerthi) algorithm finds closest points
- EPA (Expanding Polytope Algorithm) computes penetration depth
- Generates contact manifolds for response calculation

Once contacts are detected, the engine calculates response forces. For a humanoid foot striking the ground, this involves computing normal forces (preventing penetration) and friction forces (enabling push-off). Getting these forces right is essential for realistic walking simulation.

:::tip Mesh Simplification
Complex meshes slow collision detection dramatically. Use simplified convex hulls or primitive shapes (boxes, cylinders) for collision geometry, even if your visual model is detailed. A humanoid hand might use box collision shapes for fingers rather than the actual mesh geometry.
:::

## Simulation Parameters

Three key parameters control the accuracy-performance trade-off:

**Time step (dt)**: Smaller values increase accuracy but reduce speed. For humanoid robots, 1ms (0.001s) is typical; control loops often run at 1kHz. Larger steps risk missing fast events like impacts.

**Solver iterations**: Determines how accurately constraints (contacts, joints) are satisfied. More iterations reduce constraint violation but cost computation time. Start with 50 iterations and increase if you see unrealistic penetration or instability.

**ERP/CFM** (Error Reduction Parameter / Constraint Force Mixing): These ODE-specific parameters tune how aggressively the solver corrects errors. Higher ERP values more aggressively correct penetration; CFM adds softness to contacts. For humanoid robots, start with defaults and tune if you observe jittering or unnatural compliance.

## Summary and Key Takeaways

Physics simulation enables safe, rapid development of humanoid robot systems:

- **Physics engines** (ODE, Bullet, DART) solve Newton-Euler dynamics at each time step
- **Rigid body dynamics** depend on accurate mass and inertia properties
- **Collision detection** uses broad-phase filtering and narrow-phase precision
- **Simulation parameters** (time step, solver iterations) trade accuracy for speed

In the next chapter, you will learn how Unity's rendering capabilities complement physics simulation by providing photorealistic visualization and human-robot interaction scenarios.

## Self-Check Questions

1. What is the difference between broad-phase and narrow-phase collision detection?
2. Why does time step size affect simulation accuracy and stability?
3. Which physics engine would you choose for GPU-accelerated simulation with many objects?
4. What happens if solver iterations are set too low?
5. Why are inertia tensor values critical for humanoid simulation?

## References

Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. *IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*, 3, 2149-2154.

Open Robotics. (2024). *Gazebo Sim documentation*. https://gazebosim.org/docs
